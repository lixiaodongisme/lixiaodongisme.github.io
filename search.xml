<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用VLOOKUP在EXCEL中查找数据]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BD%BF%E7%94%A8VLOOKUP%E5%9C%A8EXCEL%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[最近在工作中遇到了这样一个问题，需要比对两个excel文件，找出两个表格中的差异之处。在网上看了一些资料后，发现excel自带的VLOOKUP函数可以很好的解决我的问题。为了简单起见，我将需要对比的数据单独提取出来，放到同一个表的不同两列。示例表如下：需求：是找出A列入B列中相同的数据，并且将相同的数据呈现在C列。先来看看最终的效果:以A列为基准，在A列中搜索B列的每一个数据，如果在A列中找到对应的数据，就将这条数据展示在C列，否则显示为N/A。使用的函数如下所示：1=VLOOKUP(B1,A:A,1,0) 我们只需要在C列的第一个输入这个函数，然后向下复制即可。 第一个参数B1表示要查找的数据。 第二个参数A:A表示查找的范围。 第三个参数表示区域中包含返回值的列号。例如，如果指定 B2：D11 作为区域，那么应该将 B 算作第一列，C 作为第二列，以此类推。 第四个参数表示使用精确查找还是模糊匹配，0代表精确查找。 再用一个例子来完整的说明一下VLOOKUP的使用。在工资表中，根据姓名来查找对应的基本工资，一个人只对应一个值，这就是精确查找。（工资这一列是属于所选区域中的第五列，因此第三个参数填入5）]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot(三)spring boot的配置文件详解]]></title>
    <url>%2F2019%2F02%2F17%2Fspring-boot-%E4%B8%89-spring-boot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们在开发一个项目时，肯定会用到配置文件，spring boot为我们提供了丰富的外部配置，常见的有： 核心配置文件 application.properties application.yml 命令行参数 OS环境变量 Dev属性 推荐使用YAML来写配置文件，因为相比与传统的json或者是properties格式的配置文件，YAML格式更简洁易读。YAML语法学习推荐一下阮一峰大神的YAML教程 一、核心配置文件核心配置文件是我们用的比较频率最高的一种配置方式，核心配置文件使用key-value的形式来进行配置。其中key主要分为两种： 默认属性：根据官方提供的配置文件可配置列表进行修改，spring boot将自动读取配置和初始化。 自定义属性：根据需求任意编写，但是需要自行读取配置和初始化。 1.1添加默认属性以数据库配置为例，在application.yml配置文件中添加如下：123456spring: datasource: url: jdbc:mysql://127.0.0.1:3306/douban?serverTimezone=GMT%2B8 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver 1.2添加自定义属性在 application.yml配置文件中添加一个用户的信息如下：123456user: userName: 张三 age: 18 birthday: 1991/01/01 address: &#123;province: 陕西, city: 西安, zone: 雁塔区&#125; skills: [Java, Python] 同时，spring boot也支持在系统加载的时候配置随机数：12345678user: random: secret: $&#123;random.value&#125; #随机32位MD5字符串 intNumber: $&#123;random.int&#125; #随机int数字 longNumber: $&#123;random.long&#125; #随机long数字 uuid: $&#123;random.uuid&#125; #随机uuid lessTen: $&#123;random.int(10)&#125; #随机10以内的数字 range: $&#123;random.int[1024,65536]&#125; #随机1024~65536之内的数字 1.3读取核心配置文件1.3.1使用@ConfigurationProperties批量读取属性在需要读取配置文件的类上添加@ConfigurationProperties和@Component（或@Configuration），并提供getter和setter方法。以读取上面的用户信息为例，我们编写一个绑定的类：123456789101112131415@Component //让该类被spring的IOC容器管理，也可以使用@Configuration@ConfigurationProperties(prefix = "user") // 通过prefix来绑定对应的属性public class User &#123; private String userName; private int age; private Date birthday; private Map&lt;String, Object&gt; address; private String[] skills; // 省略getter和setter方法&#125; 我们编写一个测试类打印一下这个User的值，可以看到已经读取到了配置文件中的值。1User&#123;userName='张三', age=18, birthday=Tue Jan 01 00:00:00 CST 1991, address=&#123;province=陕西, city=西安, zone=雁塔区&#125;, skills=[Java, Python]&#125; spring boot读取默认配置时也是使用了@ConfigurationProperties这个注解，具体原理可以参考之前的文章。 1.3.2使用@Value读取单个属性还是用上面那个用户信息的例子来说明如何使用@Value，我们编写一个绑定类。12345678910@Componentpublic class User &#123; @Value("$&#123;user.userName&#125;") private String userName; @Value("99") private int age; // 省略getter和setter方法&#125; 我们只需要在需要注入的属性或者setter方法上加上@Value(“${xxx}”)/@Value(“xxx”)这样就可以将配置文件中的值注入到绑定类中，并且还可以将任意值注入属性。我们打印一下User对象：1User&#123;userName='张三', age=99&#125; 注意：@Value不支持注入静态变量，可以间接通过Setter方法来注入123456private static Date birthday;@Value("$&#123;user.birthday&#125;")public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; 1.3.3@ConfigurationProperties和@Value的区别 特性 @Value @ ConfigurationProperties 批量注入 NO YES 支持松散语法 NO YES 支持支持SpringEL YES NO 支持JSR303数据校验 NO YES 注入复杂类型 NO YES 松散语法：以本例来说，java文件中的属性名为userName，为标准的驼峰命名方式。我们在yml或者properties中可以不采用驼峰命名方式，而是使用user-name。这样也可以注入成功，这就是松散语法。 spring boot中的简单数据类型：在spring boot中，8种基本数据类型，String，Date都是简单类型。 显然@ConfigurationProperties的功能更加强大，所以在开发中建议优先使用@ConfigurationProperties。 二、自定义配置文件在项目开发中，我们有时会将与项目相关的一些配置信息保存到单独的配置文件中，这时我们可以使用@PropertySource注解来读取我们自定义的配置文件。我们在resources下新建一个config.properties文件，并写入以下内容：12345678user.user-name=李四user.age=27user.birthday=1991/02/01user.address.province=陕西user.address.city=西安user.address.zone=新城区user.skills[0]=Javauser.skills[1]=JavaScript 我们知道spring boot只会默认读取application.properties和application.yml中的配置，为了让spring boot读取到我们的配置，我们需要在绑定类上加一个@PropertySource注解，并指明我们自定义配置文件的位置。12345678910111213141516@Component@ConfigurationProperties(prefix = "user")@PropertySource("classpath:config.properties") //读取自定义配置文件public class User &#123; private String userName; private int age; private static Date birthday; private Map&lt;String, Object&gt; address; private String[] skills; // 省略getter和setter方法&#125; 打印User对象可以看到自定义的配置文件已经正确读取到了。1User&#123;userName='李四', age=27, birthday=Fri Feb 01 00:00:00 CST 1991, address=&#123;city=西安, zone=新城区, province=陕西&#125;, skills=[Java, JavaScript]&#125; 注意：如果要使用自定义配置文件，必须使用.properties文件格式，目前(2.1.2版本)@PropertySource还不支持读取.yml格式的自定义配置文件。 三、spring boot多环境设置及切换我们在实际工作中，会存在很多套环境，例如开发环境、测试环境、生产环境。程序在不同的环境下可能会有不同的配置，例如数据库的连接、日志的级别等等。使用Spring Boot的Profile可以实现多场景下的配置切换，方便开发中进行测试和部署生产环境。 下面就大致介绍一下怎么使用profile配置不同环境的配置文件。 3.1使用properties配置文件使用properties文件进行多个环境的配置，创建若干个application-{profile}.properties文件用于存放不同环境特有的配置，将与环境无关的配置存放在application.properties文件中。application.properties文件中通过123以配置端口号为例，假设我们在开发环境需要使用8081端口，生产环境需要使用8082端口，我们先出分别为开发环境和生产环境创建application-dev.properties和application-pro.properties文件。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190213223358294.png#pic_center)在application-dev.properties中使用```server.port=8081```设定端口号为8081，同理，在application-pro.properties中设置端口号为8082。需要切换端口时，只需要在application.properties中指定我们需要使用的配置文件即可： spring.profiles.active=dev12345678910111213141516171819### 3.2使用yml配置文件使用yml文件配置多套环境的原理与properties相同，只是我们不需要在建多个配置文件，可以在application.yml配置文件中进行配置。```ymlserver: port: 8081spring: profiles: active: pro---server: port: 8082spring: profiles: dev---server: port: 8083spring: profiles: pro 在yml文件中，我们使用12345### 3.3使用命令行切换环境在spring boot时，我们一般是将项目打成jar包部署到服务器上，启动时我们只要加上一行```--spring.profiles.active=xxx```命令，就可以控制我们使用哪个环境的配置，非常方便。完整命令如下：```shelljava -jar xxx.jar --spring.profiles.active=dev 表示使用开发环境的配置java -jar xxx.jar --spring.profiles.active=pro 表示使用生产环境的配置 四、核心配置文件的位置以及优先级spring boot默认可以读取application.properties/application.yml这两个核心配置文件。核心配置文件可以存在与以下四个地方 file:./config file:./ classpath:./config classpath:./spring boot启动时，这四个位置的配置文件都会读取。也就是说这四个位置的配置文件可以是互补的关系。但是如果有某一项配置冲突，以优先级高的配置文件为准。优先级从上往下依次降低。 注意：如果application.yml和application.properties文件同时存在，他们之间也是互补的关系，但是application.properties的优先级高于application.yml。 五、外部配置文件与命令行参数设想一个场景，我们的项目已经开发完成，并且打成jar包准备上线发布了，这时由于一些原因，之前的某些配置需要修改。按常规的做法，我们要去代码中改好后，重新打jar包，然后再部署。这样就显得非常繁琐，spring boot为我们提供了一些办法，可以使我们不修改原有代码的同时，更改配置。 5.1命令行参数如果我们需要修改的配置很少，可以通过命令行参数的方式。上文已经提过，参考3.3使用命令行切换环境。如果需要输入多个命令，中间用空格隔开。 5.2外部配置文件如果我们需要修改的配置很多，用命令行参数修改明显是不好的。这时我们可以将所有需要修改的配置放到一个外部配置文件中。然后在启动项目时，通过--spring.config.location=D:/xxx.application这个命令来加载外部配置文件。 六、配置的优先级上面我们提到了spring boot支持的很多种配置方法。如果同一个配置出现在多个地方，优先级高的配置会覆盖优先级低的配置。现在来总结一下这些常用配置方式的优先级。 外部配置文件&gt;命令行参数&gt;核心配置文件(.properties&gt;.yml) 具体的优先级规则，可以查看官方文档中的介绍。]]></content>
      <categories>
        <category>spring boot系列</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot(二)自动装配原理 - 实例分析]]></title>
    <url>%2F2019%2F02%2F16%2Fspring-boot-%E4%BA%8C-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在了解了Spring Boot的运作原理后，现在来简单的分析一个Spring Boot内置的自动配置功能：http的编码配置。我们在常规项目中配置Http编码的时候是在web.xml添加一个filter,如：12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring boot要完成自动配置，就要满足两个条件： 能配置CharacterEncodingFilter这个Bean； 能配置encoding和forceEncoding两个参数。 1.自动配置我们在org.springframework.boot.autoconfigure.web.servlet包中找到HttpEncodingAutoConfiguration类后，可以看到源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Configuration@EnableConfigurationProperties(HttpProperties.class)// Spring 底层 @Conditional 注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效，该注解是判断当前应用是否是web应用，如果是， HttpEncodingAutoConfiguration 配置类生效；@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)// 判断当前项目有没有这个类 CharacterEncodingFilter；SpringMVC 中进行乱码解决的过滤器，如果有则 HttpEncodingAutoConfiguration 配置生效；@ConditionalOnClass(CharacterEncodingFilter.class)// 判断 application.properties 配置文件中是否存在 spring.http.encoding.enabled，如果不存在，判断也是成立的，因为 matchIfMissing=true，即缺省时默认为 true。@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpProperties.Encoding properties; public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean // 使用java方式配置CharacterEncodingFilter的Bean @ConditionalOnMissingBean // spring容器中没有这个类时 public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; @Bean public LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() &#123; return new LocaleCharsetMappingsCustomizer(this.properties); &#125; private static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123; private final HttpProperties.Encoding properties; LocaleCharsetMappingsCustomizer(HttpProperties.Encoding properties) &#123; this.properties = properties; &#125; @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; if (this.properties.getMapping() != null) &#123; factory.setLocaleCharsetMappings(this.properties.getMapping()); &#125; &#125; @Override public int getOrder() &#123; return 0; &#125; &#125;&#125; 可以看到这个类上总共有5个注解，我们分别来看这些注解的作用。 1.1@Configuration@Configuration：表示这个类是一个配置类，并将这个类加入IOC容器。 1.2@EnableConfigurationProperties@EnableConfigurationProperties(HttpProperties.class)：启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中。进入这个注解，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 在application.properties使用prefix+属性名的方式可以修改默认配置@ConfigurationProperties(prefix = "spring.http")public class HttpProperties &#123; private boolean logRequestDetails; private final Encoding encoding = new Encoding(); public boolean isLogRequestDetails() &#123; return this.logRequestDetails; &#125; public void setLogRequestDetails(boolean logRequestDetails) &#123; this.logRequestDetails = logRequestDetails; &#125; public Encoding getEncoding() &#123; return this.encoding; &#125; public static class Encoding &#123; // spring boot默认的编码格式就是UTF-8 public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; private Charset charset = DEFAULT_CHARSET; private Boolean force; private Boolean forceRequest; private Boolean forceResponse; private Map&lt;Locale, Charset&gt; mapping; public Charset getCharset() &#123; return this.charset; &#125; public void setCharset(Charset charset) &#123; this.charset = charset; &#125; public boolean isForce() &#123; return Boolean.TRUE.equals(this.force); &#125; public void setForce(boolean force) &#123; this.force = force; &#125; public boolean isForceRequest() &#123; return Boolean.TRUE.equals(this.forceRequest); &#125; public void setForceRequest(boolean forceRequest) &#123; this.forceRequest = forceRequest; &#125; public boolean isForceResponse() &#123; return Boolean.TRUE.equals(this.forceResponse); &#125; public void setForceResponse(boolean forceResponse) &#123; this.forceResponse = forceResponse; &#125; public Map&lt;Locale, Charset&gt; getMapping() &#123; return this.mapping; &#125; public void setMapping(Map&lt;Locale, Charset&gt; mapping) &#123; this.mapping = mapping; &#125; public boolean shouldForce(Type type) &#123; Boolean force = (type != Type.REQUEST) ? this.forceResponse : this.forceRequest; if (force == null) &#123; force = this.force; &#125; if (force == null) &#123; force = (type == Type.REQUEST); &#125; return force; &#125; public enum Type &#123; REQUEST, RESPONSE &#125; &#125;&#125; 前面有说到spring boot的理念是“约定大于配置”，可如果我们想修改默认配置改怎么修改呢？我们只需要在application.properties配置文件中，按照prefix + 属性名，就可以修改对应的属性。在本例中，我们如果想修改项目的默认编码为GBK，只需要在全局配置文件中添加一行代码即可，代码如下： 1spring.http.encoding.charset=GBK 通过上面的分析，我们知道了在配置文件中修改默认配置的原理。关于配置文件可配置属性，可以参考官方文档。 1.3Conditional剩下的三个注解都是ConditionalOnXXX类型的注解，这类注解都是@Conditional注解的派生注解，作用是必须是@Conditional指定的条件成立，才给容器中添加组件，配置里的内容才会生效。针对本例来说，必须@ConditionalOnWebApplication、@ConditionalOnClass、@ConditionalOnProperty三个注解对应的条件都生效，HttpEncodingAutoConfiguration配置类才会生效。 1.4快速查看当前生效的配置类在spring.factories文件中，我们可以看到有上百个默认配置，如果我们想知道当前有哪些默认配置生效了，哪些没有生效，这样一个个去分析明显是不现实的。我们可以在application.properties配置文件中添加以下配置，来快速查看当前生效的默认配置： 1debug=true 此时再启动应用时，就可以在控制台看到生效的配置与没有生效的配置，并且可以看到配置没有生效的原因。 12345678910111213141516Positive matches(生效的配置):----------------- HttpEncodingAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.web.filter.CharacterEncodingFilter&apos; (OnClassCondition) - found &apos;session&apos; scope (OnWebApplicationCondition) - @ConditionalOnProperty (spring.http.encoding.enabled) matched (OnPropertyCondition) HttpEncodingAutoConfiguration#characterEncodingFilter matched: - @ConditionalOnMissingBean (types: org.springframework.web.filter.CharacterEncodingFilter; SearchStrategy: all) did not find any beans (OnBeanCondition)...Negative matches(没有生效的配置):----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition) 2.@Conditional扩展注解除了以上解析到的注解，SpringBoot 还为我们提供了更多的有关 @Conditional 的派生注解。它们的作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效：]]></content>
      <categories>
        <category>spring boot系列</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot(一) 自动装配----约定大于配置]]></title>
    <url>%2F2019%2F02%2F14%2Fspring-boot-%E4%B8%80-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[随着spring体系的发展，我们在开发时需要配置整合的东西也越来越多，在进行开发时，繁琐的配置浪费了大量的时间与精力。此时spring boot就应运而生了。spring boot为我们整合了常用的J2EE体系，极大的简化了我们的开发。作为一名Java程序员，学习spring boot的使用，也是势在必行。spring boot的理念是“约定大于配置”，通俗的说，就是spring boot为我们提供了一套默认的配置，不需要我们再去手动的配置xml配置文件，只有当spring boot默认提供的配置不满足我们的需求时，我们再去修改默认配置。那么，spring boot是如何做到自动装配的呢？下面就通过源码来学习一下spring boot的自动装配机制。 1. @SpringBootApplication该类为spring boot的主配置类，spring boot的核心功能就是由@SpringBootApplication这个注解来实现的。进入@SpringBootApplication注解后，发现这个注解还包含了很多注解，其中比较重要的有两个，分别是@SpringBootConfiguration、@EnableAutoConfiguration 1.1@SpringBootConfiguration进入@SpringBootConfiguration后发现，该注解包含了@Configuration。@Configuration： 表示该类是一个配置类。spring boot建议我们使用该注解来代替传统的xml配置文件； @Configuration包含了@Component。所以加了@Configuration注解的类会自动纳入spring容器。 1.2@EnableAutoConfiguration进入@EnableAutoConfiguration，该注解包含了@AutoConfigurationPackage，并导入了一个AutoConfigurationImportSelector类。 1.2.1@AutoConfigurationPackage我们以往使用spring进行传统方式的开发时，需要在配置文件中定义一个scan扫描器，在xml配置了这个标签后，spring才可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean。在spring boot中，我们只需要将我们自己写的java文件，放到@SpringBootApplication所在类的包下，spring boot就可以自动的帮我们完成扫描，不需要我们再去手动配置扫描器，简化了我们的开发流程。spring boot就是使用@AutoConfigurationPackage这个注解，完成了自动扫描，原理如下：进入@AutoConfigurationPackage后发现这个注解导入了一个名为Registrar的内部类，该内部类的代码如下所示。通过 图中标注的方法，spring boot可以找到@SpringBootApplication所在类的包，并将该包与它的子包全部注册到spring容器中进行管理。 1.2.2AutoConfigurationImportSelector在我们的开发过程中，除了我们自己编写的代码外，我们还需要引用很多第三方的依赖，spring boot也可以通过自动配置，帮我们引入第三方的依赖。其原理就是通过@EnableAutoConfiguration这个注解导入的AutoConfigurationImportSelector类来实现的。 AutoConfigurationImportSelector这个类通过SpringFactoriesLoader.loadFactoryNames这个方法来加载第三方配置。源码如下：loadFactoryNames方法的第一个参数getSpringFactoriesLoaderFactoryClass()，直接返回了EnableAutoConfiguration这个类。进入SpringFactoriesLoader类后可以看到，loadFactoryNames方法又去调用了loadSpringFactories这个方法。代码如下：最终这个方法里，SpringFactoriesLoader会去加载jar包中的META-INF/spring.factories。如果找到这个文件，SpringFactoriesLoader就会搜索文件中的一个配置org.springframework.boot.autoconfigure.EnableAutoConfiguration,并读取后面的值。SpringBoot中的META-INF/spring.factories（完整路径：spring-boot/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories）中关于EnableAutoConfiguration的这段配置如下（只列出了一部分）： 12345678# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\...... 当然了，这些AutoConfiguration不是所有都会加载的，会根据AutoConfiguration上的@ConditionalOnClass等条件，再进一步判断是否加载。下篇文章我们通过HttpEncodingAutoConfiguration实例来分析整个自动配置的过程。]]></content>
      <categories>
        <category>spring boot系列</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
