<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring boot(二)自动装配原理 - 实例分析（HttpEncodingAutoConfiguration）]]></title>
    <url>%2F2019%2F02%2F15%2Fspring-boot-%E4%BA%8C-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在了解了Spring Boot的运作原理后，现在来简单的分析一个Spring Boot内置的自动配置功能：http的编码配置。我们在常规项目中配置Http编码的时候是在web.xml添加一个filter,如： 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring boot要完成自动配置，就要满足两个条件： 能配置CharacterEncodingFilter这个Bean； 能配置encoding和forceEncoding两个参数。 1.自动配置我们在org.springframework.boot.autoconfigure.web.servlet包中找到HttpEncodingAutoConfiguration类后，可以看到源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Configuration@EnableConfigurationProperties(HttpProperties.class)// Spring 底层 @Conditional 注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效，该注解是判断当前应用是否是web应用，如果是， HttpEncodingAutoConfiguration 配置类生效；@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)// 判断当前项目有没有这个类 CharacterEncodingFilter；SpringMVC 中进行乱码解决的过滤器，如果有则 HttpEncodingAutoConfiguration 配置生效；@ConditionalOnClass(CharacterEncodingFilter.class)// 判断 application.properties 配置文件中是否存在 spring.http.encoding.enabled，如果不存在，判断也是成立的，因为 matchIfMissing=true，即缺省时默认为 true。@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; private final HttpProperties.Encoding properties; public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean // 使用java方式配置CharacterEncodingFilter的Bean @ConditionalOnMissingBean // spring容器中没有这个类时 public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; @Bean public LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() &#123; return new LocaleCharsetMappingsCustomizer(this.properties); &#125; private static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123; private final HttpProperties.Encoding properties; LocaleCharsetMappingsCustomizer(HttpProperties.Encoding properties) &#123; this.properties = properties; &#125; @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; if (this.properties.getMapping() != null) &#123; factory.setLocaleCharsetMappings(this.properties.getMapping()); &#125; &#125; @Override public int getOrder() &#123; return 0; &#125; &#125;&#125; 可以看到这个类上总共有5个注解，我们分别来看这些注解的作用。 1.1@Configuration@Configuration：表示这个类是一个配置类，并将这个类加入IOC容器。 1.2@EnableConfigurationProperties@EnableConfigurationProperties(HttpProperties.class)：启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中。进入这个注解，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 在application.properties使用prefix+属性名的方式可以修改默认配置@ConfigurationProperties(prefix = "spring.http")public class HttpProperties &#123; private boolean logRequestDetails; private final Encoding encoding = new Encoding(); public boolean isLogRequestDetails() &#123; return this.logRequestDetails; &#125; public void setLogRequestDetails(boolean logRequestDetails) &#123; this.logRequestDetails = logRequestDetails; &#125; public Encoding getEncoding() &#123; return this.encoding; &#125; public static class Encoding &#123; // spring boot默认的编码格式就是UTF-8 public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; private Charset charset = DEFAULT_CHARSET; private Boolean force; private Boolean forceRequest; private Boolean forceResponse; private Map&lt;Locale, Charset&gt; mapping; public Charset getCharset() &#123; return this.charset; &#125; public void setCharset(Charset charset) &#123; this.charset = charset; &#125; public boolean isForce() &#123; return Boolean.TRUE.equals(this.force); &#125; public void setForce(boolean force) &#123; this.force = force; &#125; public boolean isForceRequest() &#123; return Boolean.TRUE.equals(this.forceRequest); &#125; public void setForceRequest(boolean forceRequest) &#123; this.forceRequest = forceRequest; &#125; public boolean isForceResponse() &#123; return Boolean.TRUE.equals(this.forceResponse); &#125; public void setForceResponse(boolean forceResponse) &#123; this.forceResponse = forceResponse; &#125; public Map&lt;Locale, Charset&gt; getMapping() &#123; return this.mapping; &#125; public void setMapping(Map&lt;Locale, Charset&gt; mapping) &#123; this.mapping = mapping; &#125; public boolean shouldForce(Type type) &#123; Boolean force = (type != Type.REQUEST) ? this.forceResponse : this.forceRequest; if (force == null) &#123; force = this.force; &#125; if (force == null) &#123; force = (type == Type.REQUEST); &#125; return force; &#125; public enum Type &#123; REQUEST, RESPONSE &#125; &#125;&#125; 前面有说到spring boot的理念是“约定大于配置”，可如果我们想修改默认配置改怎么修改呢？我们只需要在application.properties配置文件中，按照prefix + 属性名，就可以修改对应的属性。在本例中，我们如果想修改项目的默认编码为GBK，只需要在全局配置文件中添加一行代码即可，代码如下： 1spring.http.encoding.charset=GBK 通过上面的分析，我们知道了在配置文件中修改默认配置的原理。关于配置文件可配置属性，可以参考官方文档。 1.3Conditional剩下的三个注解都是ConditionalOnXXX类型的注解，这类注解都是@Conditional注解的派生注解，作用是必须是@Conditional指定的条件成立，才给容器中添加组件，配置里的内容才会生效。针对本例来说，必须@ConditionalOnWebApplication、@ConditionalOnClass、@ConditionalOnProperty三个注解对应的条件都生效，HttpEncodingAutoConfiguration配置类才会生效。 1.4快速查看当前生效的配置类在spring.factories文件中，我们可以看到有上百个默认配置，如果我们想知道当前有哪些默认配置生效了，哪些没有生效，这样一个个去分析明显是不现实的。我们可以在application.properties配置文件中添加以下配置，来快速查看当前生效的默认配置： 1debug=true 此时再启动应用时，就可以在控制台看到生效的配置与没有生效的配置，并且可以看到配置没有生效的原因。 12345678910111213141516Positive matches(生效的配置):----------------- HttpEncodingAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.web.filter.CharacterEncodingFilter&apos; (OnClassCondition) - found &apos;session&apos; scope (OnWebApplicationCondition) - @ConditionalOnProperty (spring.http.encoding.enabled) matched (OnPropertyCondition) HttpEncodingAutoConfiguration#characterEncodingFilter matched: - @ConditionalOnMissingBean (types: org.springframework.web.filter.CharacterEncodingFilter; SearchStrategy: all) did not find any beans (OnBeanCondition)...Negative matches(没有生效的配置):----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition) 2.@Conditional扩展注解除了以上解析到的注解，SpringBoot 还为我们提供了更多的有关 @Conditional 的派生注解。它们的作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效：]]></content>
      <categories>
        <category>spring boot系列</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot(一) 自动装配----约定大于配置]]></title>
    <url>%2F2019%2F02%2F14%2Fspring-boot-%E4%B8%80-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[随着spring体系的发展，我们在开发时需要配置整合的东西也越来越多，在进行开发时，繁琐的配置浪费了大量的时间与精力。此时spring boot就应运而生了。spring boot为我们整合了常用的J2EE体系，极大的简化了我们的开发。作为一名Java程序员，学习spring boot的使用，也是势在必行。spring boot的理念是“约定大于配置”，通俗的说，就是spring boot为我们提供了一套默认的配置，不需要我们再去手动的配置xml配置文件，只有当spring boot默认提供的配置不满足我们的需求时，我们再去修改默认配置。那么，spring boot是如何做到自动装配的呢？下面就通过源码来学习一下spring boot的自动装配机制。 1. @SpringBootApplication该类为spring boot的主配置类，spring boot的核心功能就是由@SpringBootApplication这个注解来实现的。进入@SpringBootApplication注解后，发现这个注解还包含了很多注解，其中比较重要的有两个，分别是@SpringBootConfiguration、@EnableAutoConfiguration 1.1@SpringBootConfiguration进入@SpringBootConfiguration后发现，该注解包含了@Configuration。@Configuration： 表示该类是一个配置类。spring boot建议我们使用该注解来代替传统的xml配置文件； @Configuration包含了@Component。所以加了@Configuration注解的类会自动纳入spring容器。 1.2@EnableAutoConfiguration进入@EnableAutoConfiguration，该注解包含了@AutoConfigurationPackage，并导入了一个AutoConfigurationImportSelector类。 1.2.1@AutoConfigurationPackage我们以往使用spring进行传统方式的开发时，需要在配置文件中定义一个scan扫描器，在xml配置了这个标签后，spring才可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean。在spring boot中，我们只需要将我们自己写的java文件，放到@SpringBootApplication所在类的包下，spring boot就可以自动的帮我们完成扫描，不需要我们再去手动配置扫描器，简化了我们的开发流程。spring boot就是使用@AutoConfigurationPackage这个注解，完成了自动扫描，原理如下：进入@AutoConfigurationPackage后发现这个注解导入了一个名为Registrar的内部类，该内部类的代码如下所示。通过 图中标注的方法，spring boot可以找到@SpringBootApplication所在类的包，并将该包与它的子包全部注册到spring容器中进行管理。 1.2.2AutoConfigurationImportSelector在我们的开发过程中，除了我们自己编写的代码外，我们还需要引用很多第三方的依赖，spring boot也可以通过自动配置，帮我们引入第三方的依赖。其原理就是通过@EnableAutoConfiguration这个注解导入的AutoConfigurationImportSelector类来实现的。 AutoConfigurationImportSelector这个类通过SpringFactoriesLoader.loadFactoryNames这个方法来加载第三方配置。源码如下：loadFactoryNames方法的第一个参数getSpringFactoriesLoaderFactoryClass()，直接返回了EnableAutoConfiguration这个类。进入SpringFactoriesLoader类后可以看到，loadFactoryNames方法又去调用了loadSpringFactories这个方法。代码如下：最终这个方法里，SpringFactoriesLoader会去加载jar包中的META-INF/spring.factories。如果找到这个文件，SpringFactoriesLoader就会搜索文件中的一个配置org.springframework.boot.autoconfigure.EnableAutoConfiguration,并读取后面的值。SpringBoot中的META-INF/spring.factories（完整路径：spring-boot/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories）中关于EnableAutoConfiguration的这段配置如下（只列出了一部分）： 12345678# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\...... 当然了，这些AutoConfiguration不是所有都会加载的，会根据AutoConfiguration上的@ConditionalOnClass等条件，再进一步判断是否加载。下篇文章我们通过HttpEncodingAutoConfiguration实例来分析整个自动配置的过程。]]></content>
      <categories>
        <category>spring boot系列</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
